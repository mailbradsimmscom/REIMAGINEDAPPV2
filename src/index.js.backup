import 'dotenv/config';
import { createServer } from 'node:http';
import { healthRoute } from './routes/health.route.js';
import { promises as fs } from 'node:fs';
import { extname, join } from 'node:path';


import { systemsListRoute, systemsGetRoute, systemsSearchRoute } from './routes/systems.routes.js';

import { enhancedChatProcessMessageRoute, enhancedChatGetHistoryRoute, enhancedChatListChatsRoute, enhancedChatGetContextRoute, enhancedChatDeleteRoute } from './routes/enhanced-chat.routes.js';
import { adminDashboardRoute, adminHealthRoute, adminLogsRoute, adminSystemsRoute, adminManufacturersRoute, adminModelsRoute, adminPineconeRoute } from './routes/admin.routes.js';
import { documentIngestRoute, documentJobStatusRoute, documentListJobsRoute, documentListDocumentsRoute, documentGetDocumentRoute } from './routes/document.routes.js';
import { pineconeSearchRoute, pineconeStatsRoute, pineconeDocumentChunksRoute, pineconeQueryRoute } from './routes/pinecone.routes.js';
import { logger } from './utils/logger.js';
import { env } from './config/env.js';
import jobProcessor from './services/job.processor.js';

// Sidecar health check function
async function checkSidecarHealth() {
  const sidecarUrl = env.pythonSidecarUrl;
  const maxRetries = 10;
  const retryDelay = 3000;
  
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      const response = await fetch(`${sidecarUrl}/health`);
      if (response.ok) {
        await logger.info('Python sidecar is healthy', { 
          sidecarUrl,
          attempt 
        });
        return true;
      }
    } catch (error) {
      await logger.warn('Python sidecar health check failed', { 
        sidecarUrl,
        attempt,
        error: error.message 
      });
    }
    
    if (attempt < maxRetries) {
      await new Promise(resolve => setTimeout(resolve, retryDelay));
    }
  }
  
  await logger.error('Python sidecar failed to start after maximum retries', { 
    sidecarUrl,
    maxRetries 
  });
  return false;
}

const server = createServer(async (req, res) => {
  const requestLogger = logger.createRequestLogger();
  const startTime = Date.now();
  
  try {
    requestLogger.info('HTTP request received', { 
      method: req.method, 
      url: req.url,
      userAgent: req.headers['user-agent']?.substring(0, 100)
    });
    
    // Serve static files (CSS and JS)
    if (req.method === 'GET' && (req.url.startsWith('/styles.css') || req.url.startsWith('/app.js'))) {
      const fileName = req.url.substring(1); // Remove leading slash
      const filePath = join(process.cwd(), 'src/public', fileName);
      try {
        const content = await fs.readFile(filePath);
        const ext = extname(filePath);
        const contentType = {
          '.css': 'text/css',
          '.js': 'text/javascript'
        }[ext] || 'text/plain';
        
        res.setHeader('content-type', contentType);
        res.end(content);
        return;
      } catch (error) {
        res.statusCode = 404;
        res.setHeader('content-type', 'application/json');
        res.end(JSON.stringify({ error: 'File not found' }));
        return;
      }
    }

    // Serve index.html for root path
    if (req.url === '/' || req.url === '/index.html') {
      try {
        const content = await fs.readFile(join(process.cwd(), 'src/public/index.html'));
        res.setHeader('content-type', 'text/html');
        res.end(content);
        return;
      } catch (error) {
        res.statusCode = 404;
        res.setHeader('content-type', 'application/json');
        res.end(JSON.stringify({ error: 'index.html not found' }));
        return;
      }
    }

    if (req.url === '/health' && req.method === 'GET') {
      return healthRoute(req, res);
    }



    // Systems routes
    if (req.url.startsWith('/systems/search') && req.method === 'GET') {
      return systemsSearchRoute(req, res);
    }

    if (req.url === '/systems' && req.method === 'GET') {
      return systemsListRoute(req, res);
    }

    if (req.url.startsWith('/systems/') && req.method === 'GET') {
      return systemsGetRoute(req, res);
    }



    // Enhanced Chat routes (with Pinecone integration)
    if (req.url === '/chat/enhanced/process' && req.method === 'POST') {
      return enhancedChatProcessMessageRoute(req, res);
    }

    if (req.url.startsWith('/chat/enhanced/history') && req.method === 'GET') {
      return enhancedChatGetHistoryRoute(req, res);
    }

    if (req.url.startsWith('/chat/enhanced/list') && req.method === 'GET') {
      return enhancedChatListChatsRoute(req, res);
    }

    if (req.url.startsWith('/chat/enhanced/context') && req.method === 'GET') {
      return enhancedChatGetContextRoute(req, res);
    }

    if (req.url === '/chat/enhanced/delete' && req.method === 'DELETE') {
      return enhancedChatDeleteRoute(req, res);
    }

    // Admin routes
    if (req.url === '/admin' && req.method === 'GET') {
      return adminDashboardRoute(req, res);
    }

    if (req.url === '/admin/health' && req.method === 'GET') {
      return adminHealthRoute(req, res);
    }

    if (req.url === '/admin/logs' && req.method === 'GET') {
      return adminLogsRoute(req, res);
    }

    if (req.url === '/admin/systems' && req.method === 'GET') {
      return adminSystemsRoute(req, res);
    }

    if (req.url === '/admin/systems/manufacturers' && req.method === 'GET') {
      return adminManufacturersRoute(req, res);
    }

    if (req.url.startsWith('/admin/systems/models') && req.method === 'GET') {
      return adminModelsRoute(req, res);
    }

    if (req.url === '/admin/pinecone' && req.method === 'GET') {
      return adminPineconeRoute(req, res);
    }

    // Document processing routes
    if (req.url === '/admin/docs/ingest' && req.method === 'POST') {
      return documentIngestRoute(req, res);
    }

    if (req.url.startsWith('/admin/docs/ingest/') && req.method === 'GET') {
      return documentJobStatusRoute(req, res);
    }

    if (req.url.startsWith('/admin/docs/jobs') && req.method === 'GET') {
      return documentListJobsRoute(req, res);
    }

    if (req.url.startsWith('/admin/docs/documents') && req.method === 'GET') {
      // Check if it's a specific document ID (has more than just /admin/docs/documents)
      if (req.url.split('/').length > 4) {
        return documentGetDocumentRoute(req, res);
      }
      return documentListDocumentsRoute(req, res);
    }

    // Pinecone routes
    if (req.url === '/pinecone/search' && req.method === 'POST') {
      return pineconeSearchRoute(req, res);
    }

    if (req.url === '/pinecone/stats' && req.method === 'GET') {
      return pineconeStatsRoute(req, res);
    }

    if (req.url.startsWith('/pinecone/document/') && req.url.includes('/chunks') && req.method === 'GET') {
      return pineconeDocumentChunksRoute(req, res);
    }

    if (req.url === '/pinecone/query' && req.method === 'POST') {
      return pineconeQueryRoute(req, res);
    }

    res.statusCode = 404;
    res.setHeader('content-type', 'application/json');
    res.end(JSON.stringify({ 
      success: false,
      error: 'Not Found' 
    }));
    
    requestLogger.warn('404 Not Found', { url: req.url });
  } catch (error) {
    res.statusCode = 500;
    res.setHeader('content-type', 'application/json');
    res.end(JSON.stringify({ error: 'Internal Server Error' }));
    
    requestLogger.error('Internal Server Error', { 
      error: error.message,
      url: req.url,
      stack: error.stack
    });
  } finally {
    const duration = Date.now() - startTime;
    requestLogger.performance('http_request', duration, { 
      method: req.method, 
      url: req.url,
      statusCode: res.statusCode
    });
  }
});

  const port = env.port;

// Start server with sidecar health check
async function startServer() {
  try {
    // Check sidecar health before starting server
    const sidecarHealthy = await checkSidecarHealth();
    
    if (!sidecarHealthy) {
      await logger.warn('Starting server without healthy sidecar - some features may not work');
    }
    
    server.listen(port, async () => {
      await logger.info('Server started', { 
        port, 
            environment: env.nodeEnv,
    version: env.appVersion,
        sidecarHealthy
      });
      
      // Start the job processor
      try {
        await jobProcessor.start();
        await logger.info('Job processor started');
      } catch (error) {
        await logger.error('Failed to start job processor', { error: error.message });
      }
    });
  } catch (error) {
    await logger.error('Failed to start server', { error: error.message });
    process.exit(1);
  }
}

startServer();

export default server;


